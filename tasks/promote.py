from celery import shared_task
from flask import current_app  # Added current_app
from models.content import Content
from models.user import User  # Assuming current_user will be passed by ID and fetched
from helpers.gemini import SocialPostGenerator  # Updated import path
from helpers.gemini import validate_post_length  # Updated import path
from extensions import (
    db,
)  # For database access if needed, though fetching user might be better in endpoint
import logging

# Import for LinkedIn posting - conditional logic will be used
from helpers.arcade import (
    post_to_linkedin as post_to_linkedin_arcade,
)  # Renamed for clarity
from helpers.linkedin_native import post_to_linkedin_native
from services.slack_service import send_slack_dm  # Import the Slack DM helper

logger = logging.getLogger(__name__)


@shared_task(bind=True, ignore_result=False, max_retries=3, default_retry_delay=60)
def generate_social_media_post_task(self, content_id: int, user_id: int):
    """
    Celery task to generate social media posts for a given content_id and user_id.
    """
    try:
        content = Content.query.get(content_id)
        user = User.query.get(user_id)

        if not content:
            logger.error(f"Content with ID {content_id} not found.")
            # Optional: raise an exception to mark task as FAILED if content not found
            raise ValueError(f"Content with ID {content_id} not found.")
        if not user:
            logger.error(f"User with ID {user_id} not found.")
            raise ValueError(f"User with ID {user_id} not found.")

        logger.info(
            f"Starting social media post generation for content_id: {content_id}, user_id: {user_id}"
        )

        warnings = []
        linkedin_post = None

        if content.copy and content.copy.strip():
            logger.info(f"Using provided copy for content_id: {content_id}")
            linkedin_post = content.copy
            # Optionally, validate length of provided copy
            is_valid, length = validate_post_length(linkedin_post, "linkedin")
            if not is_valid:
                warnings.append(
                    f"LinkedIn: Provided copy may exceed character limit ({length} characters). Please review and edit if necessary."
                )
        else:
            logger.info(
                f"No provided copy for content_id: {content_id}. Generating with AI."
            )
            post_generator = SocialPostGenerator()
            generated_posts = post_generator.generate_all_platform_posts(content, user)
            linkedin_post = generated_posts.get("linkedin")

            if user.linkedin_authorized and linkedin_post is None:
                warnings.append("LinkedIn: Post generation failed.")
            elif linkedin_post:  # Only validate if a post was generated by AI
                is_valid, length = validate_post_length(linkedin_post, "linkedin")
                if not is_valid:
                    warnings.append(
                        f"LinkedIn: AI-generated post may exceed character limit ({length} characters). Please review and edit if necessary."
                    )

        logger.info(
            f"Successfully processed social media posts for content_id: {content_id}"
        )

        return {
            "linkedin": linkedin_post,
            "warnings": warnings,
            "content_id": content_id,  # Include content_id for reference
        }

    except Exception as e:
        logger.error(
            f"Error in generate_social_media_post_task for content_id {content_id}, user_id {user_id}: {str(e)}"
        )
        # This will mark the task as FAILED and store the exception info
        raise self.retry(
            exc=e, countdown=self.default_retry_delay * (2**self.request.retries)
        )


@shared_task(bind=True, ignore_result=False, max_retries=3, default_retry_delay=60)
def post_to_linkedin_task(self, user_id: int, content_id: int, post_content: str):
    """
    Celery task to post content to LinkedIn for a given user.
    Uses native or Arcade based on NATIVE_LINKEDIN config.
    Args:
        user_id: The ID of the user posting the content
        content_id: The ID of the content being posted about
        post_content: The content to post to LinkedIn
    """
    try:
        # It's important for Celery tasks that might run outside a Flask app context
        # to create their own app context if they need current_app.config.
        # However, for shared_task, if the app is configured when Celery starts, it might be available.
        # For robustness, an app context can be pushed if direct current_app access is problematic.
        # For now, assuming current_app is accessible as configured in Flask app factory for Celery.

        from models import (
            User,
            Content,
            Share,
        )  # Keep imports inside task if they use db

        user = User.query.get(user_id)
        content = Content.query.get(content_id)

        if not user:
            raise ValueError(f"User with ID {user_id} not found.")
        if not content:
            raise ValueError(f"Content with ID {content_id} not found.")

        # The general linkedin_authorized flag should still be checked first.
        # Specific token checks are done within the native/arcade functions.
        if not user.linkedin_authorized:
            raise ValueError(
                "User is not generally authorized for LinkedIn. Please connect/re-connect."
            )

        logger.info(
            f"Starting LinkedIn post for user_id: {user_id}, content_id: {content_id}"
        )

        response_data = None
        if current_app.config.get("NATIVE_LINKEDIN"):
            logger.info(f"Using NATIVE LinkedIn integration for user {user_id}.")
            # Ensure user has native tokens before attempting, though post_to_linkedin_native does its own checks.
            if not user.linkedin_native_access_token:
                raise ValueError(
                    "User is not authorized for Native LinkedIn posting. Missing access token."
                )
            response_data = post_to_linkedin_native(user, post_content)
        else:
            logger.info(f"Using ARCADE LinkedIn integration for user {user_id}.")
            response_data = post_to_linkedin_arcade(user, post_content)

        # Create Share record
        # The native function returns {"status": "success", "id": post_id, "url": post_url}
        # The arcade function (presumably) returns {"url": ..., ...} - adjust based on actual arcade response
        post_url = (
            response_data.get("url")
            if response_data and "url" in response_data
            else None
        )
        # If native, response_data might also contain an 'id' for the post
        # post_id_from_response = response_data.get('id') if response_data else None

        share = Share(
            user_id=user_id,
            content_id=content_id,
            platform="linkedin",
            post_content=post_content,
            post_url=post_url,
            # Consider adding platform_post_id=post_id_from_response if you want to store it.
        )
        db.session.add(share)
        db.session.commit()

        logger.info(
            f"Successfully recorded share for LinkedIn post by user {user_id}. Post URL: {post_url}"
        )

        return {
            "status": "SUCCESS",
            "message": "Posted to LinkedIn successfully!",
            "post_url": post_url,
        }

    except ValueError as ve:  # Catch specific ValueErrors first (e.g., auth issues)
        logger.error(
            f"ValueError in post_to_linkedin_task for user {user_id}, content {content_id}: {str(ve)}"
        )

        # Check if this is a 401 error (token revoked/expired)
        error_str = str(ve).lower()
        if "401" in error_str or "unauthorized" in error_str or "token" in error_str:
            # Send Slack DM if user has a Slack ID
            if user and user.slack_id:
                try:
                    base_url = current_app.config.get("BASE_URL", "").rstrip("/")
                    profile_url = f"{base_url}/auth/profile"
                    dm_text = (
                        f"Hi there! We tried to post to LinkedIn for you, but it looks like your authorization has expired or been revoked. "
                        f"Please reconnect your LinkedIn account by visiting your profile page: {profile_url}"
                    )
                    send_slack_dm(user.slack_id, dm_text)
                    logger.info(
                        f"Sent Slack DM to user {user_id} ({user.slack_id}) about LinkedIn re-authentication."
                    )
                except Exception as slack_err:
                    logger.error(
                        f"Failed to send Slack DM to user {user_id} ({user.slack_id}): {str(slack_err)}"
                    )
            else:
                logger.warning(
                    f"User {user_id} requires LinkedIn re-authentication but has no Slack ID for notification."
                )

        # Do not retry on auth errors or configuration issues by default, let it fail.
        # Or, use self.update_state(state=states.FAILURE, meta=str(ve)) and return to avoid retry.
        raise  # Re-raise to mark task as failed
    except Exception as e:
        logger.error(
            f"Error posting to LinkedIn for user {user_id}, content {content_id}: {str(e)}"
        )
        # Retry for other types of exceptions (network, temporary API issues)
        raise self.retry(exc=e)


# To ensure this task is discoverable by Celery, you might need to import this module
# in your main celery_app.py or within the `include` list of your Celery app.
# Example in celery_app.py:
# import tasks.promote
# OR celery = Celery(..., include=['tasks.content', 'tasks.promote'])
